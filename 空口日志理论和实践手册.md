TL;DR
本文以802.11空口日志为核心主题进行了介绍和论述。

若只想快速学习抓包手法，请看第二章第三节，并下载我写好的脚本。



前言
在日常开发工作的过程中，我们经常会碰到需要空口日志进行分析的情况。这种情况主要集中在跟Wi-Fi/802.11协议相关的工作中。

可能项目初期这种情况并不多见，空口日志并不是必需的。

但是随着开发工作的深入，Wi-Fi模块可能遇到各种稀奇古怪的问题，那此时就很有可能需要空口日志来定位到底问题出现在了哪里。

可以说，空口日志是定位和调试Wi-Fi模块问题必要条件之一； 没有空口日志，调试Wi-Fi模块问题力度就会大打折扣，难度也会成倍增加。

所以，我们必须熟练掌握空口日志的各种性质和特点，熟悉它的常见抓取和分析方式，以及典型问题的空口特征等。

希望通过阅读本文，开发和测试同学都能从中找到适合自己的内容，对于今后的空口日志相关工作可以些许提升效率，那本文的目的也就达到了。



一、空口介绍
本章内容主要是以涉及到空口日志各种名词、概念、定义、特征为主。

1. 什么是空口日志？
(1) 空口日志的定义
空口日志，顾名思义，就是传播在空气中的数据形成的日志。或者更直接一点，就是以无线电磁波为载体传输的数据形成的日志。

类比一下，声音这种通过声波传输的数据也可以形成日志，这种日志里包含的信息可以被保存和分析，那么空口日志也是一样的，毕竟声波和电磁波都是波嘛。

空口日志对于分析定位Wi-Fi、蓝牙、Modem等方面的问题是十分有必要的。

以上说的是空口日志概念的外延。

在本文里，我们说的空口日志特指与Wi-Fi模块紧密相关的一种日志形式，它的主要内容是802.11帧，这是空口日志概念的内涵。



关于空口日志，目前常见的一些说法中，正确的有：空口log、air log、sniffer log(高通/MTK常用这种说法)等等。Sniffer这个词来源于抓包工具的通称。

而错误的说法则有：tcpdump log -- 这种说法是错误的，是因为tcpdump是一种抓包工具名称，而不是日志类型的名称，对不同的人有不同的理解，就像土豆/地瓜这个词在不同的语境下有不同的理解一样。



(2) 空口日志的文件类型
空口日志，在计算机和其他设备上保存起来的文件类型有很多，一般以如下常见文件类型来呈现：

.pcap：这是Wireshark可以直接打开的文件类型，所以最常见。我们保存/写入时一般都指定这个文件类型。
.pcapng：这也是Wireshark可以直接打开的文件类型，ng代表next generation。理论上说，这种文件类型应该比上一种更先进，支持一些高级特性，但是目前在Windows10上没有看出明显的区别来。
.pkt：这是Omnipeek默认保存的文件格式。没啥特点，也可以被Wireshark直接打开。
.wpz：这是Omnipeek可以使用的第二种空口保存格式，但是是compressed(压缩的)，抓包数据保存之后文件大小上有优势。所以使用Omnipeek抓包时推荐保存为这种格式。
(3) 什么样的日志不是空口日志
关于空口日志，有一个容易混淆的概念，这里需要着重澄清一下，那就是空口日志和网络日志不是一个东西。

空口日志指的是，不同设备的Wi-Fi模块在空中交互的数据帧形成的日志；网络日志，一般是指网络数据包交互形成的日志。

这是两个互相垂直的概念，不是并行的概念，也不是相反的概念。

它们唯一的交集是，Wi-Fi上面可以承载网络数据包。



举例来说，Wi-Fi可以承载IPv4网络数据包的交互，也可以交互非IPv4数据包，不论是哪种数据包，都是被封装在802.11帧中交互的。

而网络数据包，可以通过Wi-Fi模块交互，也可以通过Modem模块交互，还可以通过蓝牙模块交互。

类比一下，如果把网络数据包比喻成人民币的话，那么网络日志就是人民币流动过程的日志；而Wi-Fi可以比喻成银行外汇这条路径(类似地，还有现金、国债、钱庄等路径)，那么空口日志就是记录外汇的流入流出过程的日志。

网络日志和空口日志都可以经由tcpdump抓取，这可能是比较容易让人迷惑的地方。

经过上面的描述，同学们应该可以分清两者的区别了。



再次强烈建议测试同学们保存日志时使用特定的名称，空口日志使用air.pcap这样形式的命名，网络日志使用net.pcap这样形式的命名，便于用到这两种日志的同学区分和保存。



2. 空口日志的特征
空口日志的具有以下几大特征。仔细分辨下面的几大特征，对于理解空口日志抓取和分析是很有好处的。



(1) 独立性
空口日志实际上是较为独立的，离其他的日志形式距离较远，联系也比较薄弱。

一般来说，它只和Wi-Fi模块的驱动/固件日志产生直接的联系，我们可以通过一些关键事件把空口日志和它们两个联系起来。

在日常的工作中，我们一般不关心空口日志的具体内容，就好像我们不关心网线中流动的数据到底是什么样子一样。

只有一些比较特殊的场景，基本都是空口出错的场景，我们才需要空口日志来进行分析。

当然，这并不意味着空口日志不重要，事实上，它几乎是正面分析802.11帧的唯一手段。

(2) 正确性
空口日志抓取时，抓包机必须工作在正确的信道上，才能抓取到正确的、想要的日志。

众所周知，Wi-Fi工作时处于某一个特定的信道上，它是不会像蓝牙一样进行跳频的。所以进行抓取时，必须指定正确的工作信道才行。

除此之外，还有频宽这个变量：在2.4GHz上时，一般使用20MHz频宽；在5GHz上时，一般使用80MHz频宽。

这两点在后面的抓包工具使用时会再详细描述。

(3) 不可兼顾性
一个Wi-Fi设备不可能一边处于收发数据包，一边进行抓包；也就是说，一个Wi-Fi设备要么处于正常工作的收发数据包模式，要么处于抓包模式，这两者是不可能共存的。

这是由于：

无线网卡一般有四种工作模式，即 Managed，Master，Ad-hoc，Monitor。

Managed 模式：该模式用于你的无线客户端直接与无线接入点（Access Point，即AP）进行接入连接。在这个模式中，我们可以进行无线接入internet上网，无线网卡的驱动程序依赖无线AP管理整个通信过程。

Master 模式：一些无线网卡支持Master模式。这个模式允许无线网卡使用特制的驱动程序和软件工作，作为其他设备的无线AP。它主要使用于无线接入点AP提供无线接入服务以及路由功能。比如无线路由器就是工作在Master模式下了，对于普通的pc机来说，如果有合适的硬件它也可以变成一台无线AP。

Ad hoc模式：当你的网络由互相直连的设备组成时，就使用这个模式。在这个模式中，各设备之间采用对等网络的方式进行连接，无线通信双方共同承担无线AP的职责。

Monitor 模式：Monitor模式主要用于监控无线网络内部的流量，用于检查网络和排错。要使Wireshark捕获无线数据包，你的无线网卡和配套驱动程序必须支持监听模式（也叫RFMON模式）。

所以收发包实际上是managed模式，抓包实际上是monitor模式，这两者是不能共存的。



由此引申出一个错误的使用场景，那就是想要抓某一个Wi-Fi的数据包时，却把抓包机连接到了这个Wi-Fi上。

现在我们知道，这个操作是不能执行抓包动作的，所以不能这么干。

(4) 不完整性
当双端设备进行数据帧交互时，第三方的抓包机实际上是在一旁监听，它把听到的所有数据帧都记录下来。

这种工作模式一般称之为混杂模式(Promiscuous)，简单说就是网卡把所有经过的数据包都记录下，而不仅仅是目的地址是它的数据包。

而默认情况下，一个Wi-Fi设备对于单播目的地址不是它自己的地址数据包是抛弃的。这就是抓包的原理。



那么问题来了，抓包机能听到所有的数据包吗？

答案是不行的。信号越强，听到的数据包越多，但是总会有疏漏的数据包没有记录下来。



所以，当我们查看数据包时，实际上看的只是一部分数据包，而不是所有的数据包。这点要时刻牢记。



另外，不完整性还体现在单个数据包上。在查看空口包时，我们经常能看到下面这种包：

![image](https://github.com/cl6744/private/assets/45474106/b786b515-9d3c-4137-8cf9-14c9d8f9e279)


它的意思是畸形的/损坏的，我们可以看到这种包有缺损。这也是不完整性的一种体现。

(5) 加密性
默认情况下，空口数据包为了防止被第三方嗅探/Sniffer，都会进行加密动作，所以我们的看到的数据帧一般都是加密过的。

但是，这对于我们想要进行debug问题是非常不利的。



想要解开加密数据包，除了拥有空口密钥，还必须抓取到整个Wi-Fi/P2P建立连接的全过程。

这点就比较难了。如果复现问题的时候，在距离关联过程比较远的地方，例如十几个小时，那不就意味着我们得把这十几个小时的空口数据都记录下来吗？

这是难度很高且非常不便利的。



所以我们建议，在有可能的条件下，尽量采取不加密的形式来抓取空口数据包。比如：

把手机热点安全方式设置成open后测试设备再连接到手机热点上
把路由器安全方式设置成open后试设备再连接到路由器上
这样做的话，我们抓取的空口日志就是明文的，我们直接就可以看到数据帧内容，这对于我们问题定位时是极大的便利。



但也有一些情况下，这样做是行不通的，比如P2P或者安全限制，那么这时就需要采取一些别的措施了，见FAQ。



(6) 纯净度
空口日志中，一般只有两个或者三个设备之间交互的数据帧才是我们想要的。其他设备间交互的帧都是所谓的杂包，跟我们的分析不沾边甚至会造成干扰。

所以，我们建议抓取空口时一般要到屏蔽室里面去，这样抓取的日志纯净程度才最高。



当然，也有一些情况下确实没有这个条件，屏蔽室资源实在紧张，协调不出来。那么我们也可以退而求其次，到办公楼的楼梯间去进行抓包。

由于钢筋混凝土和铁门的隔离性，它们对于Wi-Fi信号也是具有一定的屏蔽作用的，这样的情况下抓取的日志纯净程度也比较好。



实在没办法的话，就只能在工位上抓取了，这样的话纯净程度就比较差，万一没抓到就只能重新抓取了。

3. 什么样的日志才是好的空口日志？
综合上面的几项特征，我们可以得知，一个好的空口日志具有如下几个基本特征：

不加密：虽然提供密钥和关联包可以解密空口包，但不是所有的空口包都可以解密成功。所以不加密的才是最好的。
高度纯净：在屏蔽室内抓取的空口包，可以最大程度避免其他设备的干扰。
不缺损：这点很简单，缺损数据包很少或者没有。


具有以上特征的日志就是好的空口日志。



另外，好的空口日志一般还有一个重要的特点，那就是文件大小合适。

太大的空口文件打开、过滤、保存的速度都很堪忧，实际上是非常影响分析效率的。

如果空口文件大小只有几个KB，不用说，肯定是没有抓到导致内容是空的，重新抓吧！

二、如何抓取空口日志
这一章节是整篇文章的难点。我将详述各种抓取手法和使用到的工具，同学们可以根据身边的环境挑选一种合适的来使用。



1. 前提条件
(1) 确定信道和频宽
想要进行空口抓包，必须首先确定哪些设备将会交互802.11帧和该Wi-Fi工作时的信道/频宽。



比如，一台手机和一台路由器交互，那么路由器的工作信道就是我们抓包时指定的信道；

再比如，一台手机和另一台手机热点交互，那么热点手机工作的信道就是我们抓包时指定的信道；

或者，一台手机和一台PC进行P2P交互，那么PC作为GO时工作的信道就是我们抓包时指定的信道。



掌握以上的原则， 基本上，一个Wi-Fi网络里总有一个类似于AP的角色，它是给其他设备提供Wi-Fi网络接入的，其他设备此时扮演的就是STA的角色。

那么此时，这个类似于AP的角色的信道就是我们要抓包的信道。

至于频宽，一般情况下，2.4GHz使用20MHz而5GHz使用80MHz即可。



(2) 确定支持的标准
通常情况下，抓包网卡支持的协议标准不能低于交互的数据帧的标准。

简单来说，就是支持Wi-Fi6的无线网卡才能抓取Wi-Fi6数据包，Wi-Fi5无线网卡是抓取不了Wi-Fi6数据包的。



(3) 天线数量
还有一项很少遇到但很重要的原则，那就是抓包网卡的天线数量要大于等于交互的Wi-Fi设备的天线数量。

比如，两天线的抓包网卡可以用来抓取使用两天线的Wi-Fi设备的数据帧。

这个条件目前一般都是满足的，所以不用考虑。



(4) 抓包距离
抓包机距离测试设备尽量近，但也不要紧贴着，紧贴着反而会影响数据包收发，保持1分米以上的距离。



2. 常用工具
我们经常用到的抓包工具，按常见程度从上到下依次是：

Tcpdump
Intel PC
MacBooK Pro
Omnipeek
Wireshark
NetworkMonitor
IxVeriwave
路由器


下面将一一介绍这些工具的使用。



3. 使用方法
(1) Tcpdump
Tcpdump是我们最常见的抓包工具。实际上，它不仅能抓空口数据包，还能抓取网络数据包。这也是有的同学分不清这两种日志的原因之一。

我们使用它抓取空口包时，一般要搭配一台高通手机使用，比如ELZ/LGE/PGT等等，这是因为高通手机设置monitor模式最简单也最方便，MTK目前不支持。

如果要抓取网络日志，那任何一台手机都可以，这里就不赘述了。



首先，准备一台root过的ELZ手机，必须有root权限才行。

其次，把tcpdump工具和iwpriv工具push到手机上(这些命令，刷机之后执行过一次就行)：

adb root
adb remount
adb push iwpriv /system/bin
adb shell chmod 777 /system/bin/iwpriv
adb push tcpdump /vendor/bin
adb shell chmod 777 /vendor/bin/tcpdump
adb shell ls -l /system/bin/iwpriv
adb shell ls -l /vendor/bin/tcpdump
adb shell mkdir -p /data/tmp/
pause



再次，把ELZ的无线网卡wlan0置成monitor模式(这些命令，重启之后执行过一次就行)：

adb shell "svc wifi disable"
adb shell stop
adb shell "sleep 1"
adb shell "rmmod wlan"
adb shell start
adb shell "sleep 10"
adb shell "insmod /vendor/lib/modules/qca_cld3_wlan.ko con_mode=4"
adb shell "sleep 1"
adb shell "ifconfig wlan0 up"
pause

然后，设置抓包参数信道和频宽(这些命令，每次抓包都需要执行)：

adb shell "iwpriv wlan0 setMonChan 36 2"
adb shell "sleep 1"
adb shell "tcpdump -i wlan0 -v -w /data/tmp/air.pcap"

最后，把抓包文件pull出来(这些命令，抓完包之后执行一次就行)：

adb shell killall -9 tcpdump
adb pull /data/tmp/air.pcap
pause

使用tcpdump抓包是最简单的一种方法，只需要按照次序执行上面的命令行就行，最后得到的air.pcap就是空口日志了。



为了简便，我把写好的脚本贴在这里，按照1、2、3、4的顺序执行就可以了。

sniffer.rar



注意事项：

复制粘贴命令行一步一步执行的话，基本不会报错；但是如果图方便执行脚本的话，需要注意执行时每一步是否报错
如果有意外报错，尝试把该步的命令行粘贴执行，或者重启手机再执行一次
如果这次抓取的信道和上次相比没变化，那么可能会在setMonChan卡住几秒，这不是问题
![image](https://github.com/cl6744/private/assets/45474106/58a69bbe-3cea-411f-8f96-9f0eba7b3f0f)

如果没有使用ELZ，而是使用LGE，需要把脚本中两处红色wlan替换成qca6490
如果没有使用ELZ，而是使用PGT，需要把脚本中两处红色wlan替换成kiwi_v2
setMonChan的第一个参数代表抓包信道，第二个代表频宽
所以想要抓取2.4GHz信道，如信道1，记得把setMonChan的第二个参数改为0，代表20MHz：
adb shell "iwpriv wlan0 setMonChan 1 0"
2代表80MHz，1代表40MHz(一般用不到)


需要特别注意的是，我把空口日志air.pcap放置到了/data/tmp下。

这是因为，虽然几率不大但确实有这样一种可能，抓包文件不只一个，可能上百个。

这时手动pull每一个文件就显得效率很低了。

此时，我们只需要pull出来tmp这个文件夹即可：adb pull /data/tmp/。



掌握以上的技巧基本上就可以应付普通情况的抓包了。下面我们说明几种特殊的情况，用于第三步tcpdump命令的变种。

I. 抓包数据量巨大，但是我们需要的数据量很少
这种情况一般体现在长时间或者打流业务里面，比如长时间传输文件、长时间投屏、iPerf打流等等。特点是长时间或者大量传输业务和无用数据。

比如iPerf打流，里面全是00 ~ FF的重复数据；或者传输文件，我们不关心文件内容，只关心什么时候Wi-Fi出了异常状况等等。

此时，我们就可以采取截取的方式，只截取全部数据帧的一部分关键数据，而把无用的数据抛弃，这样做可以明显缩小空口包文件的大小。



针对这种情况，我们使用tcpdump的-s参数：adb shell "tcpdump -i wlan0 -s 300 -v -w /data/tmp/air.pcap"

这样做的含义是，我们只抓取一个802.11帧的前三百个字节，而抛弃后面的所有字节。

由于大部分的802.11帧的头部和负载都在300字节以内，所以此时几乎所有有意义的字节都已经获取下来了。



熟练使用-s参数可以明显减小空口包文件体积，测试同学尤其需要注意这一点。

不然经常动不动几个G、十几个G的抓包文件，不但拷贝、存放费力，打开时也容易出现异常。



II. 抓包数据量巨大，可以分开保存
这种情况一般体现在数据量特别巨大，且所有的数据都需要的情况下。

如果不做任何修正，最后很有可能形成一个奇大无比的抓包文件，不便于保存、打开和分析。



针对这种情况，我们使用tcpdump的-C参数，可以指定每一个保存的抓包文件大小：adb shell "tcpdump -i wlan0 -v -w /data/tmp/air.pcap -C 100M"

上面命令的含义是，我们可以令每一个抓包文件的保存大小为100MB。

这样做的话，我们将会看到类似air.pcapxx(xx为纯数字)形式命名的抓包文件。

如此一来，我们只需要分析出问题时间点附近的几个pcap文件就可以了，不需要从头看起。在拷贝、存放、打开抓包文件时就显得特别便利。



III. 综合以上两点，当需要抓取的数据量很大时，可以结合两者使用
比如，当需要通过Wi-Fi传输一个64GB的文件时，可以使用如下的命令：adb shell "tcpdump -i wlan0 -s 300 -v -w /data/tmp/air.pcap -C 100M"

这样的话，当64GB的文件传输完时，我们抓取到的空口数据包可能只有十几个100MB大小的pcap文件而已。



IV. 在另外一种情况下，tcpdump还可以即时的展示抓取到的数据包，而不是保存起来
比如，我们只是需要粗略的看一下抓取到的数据包而已，可以使用如下的命令：adb shell "tcpdump -i wlan0 -vvv -XX"



这样就可以对抓取到的数据包进行大体上的查看，而不用pull出来了。



总体上，tcpdump是最简单、最方便的一种抓包形式，但是需要对命令行稍稍熟悉一些，所以相当于有一点点门槛。



(2) Intel PC
另外一种常见的抓包工具是Intel系列PC，型号包括HiggsE/F等，使用的是AX200/AX201系列无线网卡。

但不能使用AX101系列网卡，因为它是单天线的。



首先，安装好Intel提供的网卡驱动，越新越好，这里推荐22.200以上。





其次，安装好WRT工具并打开。



再次，打开Sniffer界面，配置好想要抓取的信道和频宽。





开始抓包，打开Start record按钮，注意右下角的counters计数器发生了变化。





结束抓包，关闭Start record按钮。



结束抓包后，页面会提示空口日志的保存路径。



注意，此时要进入到该路径下查看，如果有SnifferDump文件夹下有pcap文件才说明确实抓到了空口包。

如果没有就说明抓包失败，需要重新抓取。



Intel无线网卡相对于tcpdump抓包的特点是，它是自行分割文件大小的，不用人工干预，每个文件的大小在10多MB左右。

(3) MacBook
这也是一种比较常见的抓包方法，设置也比较简单，就是MacBook不太常见。

条件所限就不一一截图了，大家可以参考这个教程：

使用Mac电脑上的[无线诊断]实现WiFi无线空口抓包



(4) Omnipeek
Omnipeek是市面上常见的一种商业抓包软件，需要付费。我们一般使用破解版。



在安装时，需要注意的是，注册机会根据Omnipeek的版本来生成注册密钥。先在Omnipeek的关于中查看当前版本，然后在注册机中输入。



目前，Omnipeek支持的无线网卡型号很少，且需要特殊的驱动才能抓包(所谓特殊的驱动就是指能把无线网卡配置成monitor模式)。

在这些网卡中，最高只支持到11ac，也就是Wi-Fi5。所以想要进行Wi-Fi6的抓包是不能使用Omnipeek的。



Omnipeek的使用比较简单，点击New Capture：





首先查看网卡的工作模式，选中可以使用的无线网卡。





然后选择想要抓取的信道。值得一提的是，Omnipeek是支持全信道抓取的，也就是说，你在Scan Options里勾选了哪些信道，Omnipeek就会在这些信道中轮流抓取。





抓取完成后，记得把保存文件的格式选为wpz。



值得一提的是，在capture option中也有可以指定抓包参数的地方，可以配置的项很多。







由于我这里没有支持的网卡，不能实际进行抓包，只能演示到这里为止。



找到一份视频培训教程，大家可以去参考一下。

\\10.145.4.3\HonorProtocol\培训资料\四合一\WIFI\WIFI培训\主线培训\空口的培训&空口log\2020-10-31 19.02.53 培训 731727\



(5) Wireshark
是的，我们常用的Wireshark也是能抓空口包的！但是我之所以放到这么后面的地方才说，是因为有个特殊的限制。

那就是Wireshark必须使用定制无线网卡才能进行抓包的动作，这个无线网卡就是Riverbed公司的某个型号网卡，而且还挺贵的。



买到这块网卡之后还需要安装AirPcap驱动。



之后，Wireshark可以调出wireless tool bar，在这个工具栏中可以配置想要抓取的信道和频宽等参数。





更新：又找到一个利用现有的荣耀笔记本电脑来进行抓包的方法，不过需要安装Ubuntu系统。

条件所限没有尝试，有兴趣的同学可以一步一步跟随教程试一下。

Wireshark大法-WiFi6无线抓包



(6) NetworkMonitor
NetworkMonitor是一款微软出品的轻量级抓包工具。

我也没有用过，有想尝鲜的同学可以参考下面的链接：

802.11数据包分析1：抓包工具（Microsoft Network Monitor）



(7) IxVeriWave
IxVeriWave是被Keysight公司收购的Ixia公司出品的一组测试套件，包含了一整套的软硬件自动化环境。

这个我只见过一次，类似于Spirent Testcenter的一个机箱，报价很贵。





(8)路由器抓包
某些路由器，比如高通芯片的路由器，也能用来抓包。

安全所限，无法展示。

三、空口预处理与分析
本章的主要内容包括空口日志文件的预处理和分析方法论，是此文档的核心内容。

只有彻底熟悉本章的内容后，才能对空口数据文件进行正确的处理和分析。

其中，Wireshark的使用更是重中之重，毕竟此工具是免费的，且有很多便利的手段对它进行操作。

掌握Wireshark的使用技巧，可以大幅提高定位问题的效率。



1. 预处理
什么是预处理？简单来说，就是在进行正式分析之前，对抓包进行纯净化处理，只过滤出我们想要的数据包，这样分析起来比较容易看到问题的所在。

有的同学可能会问，这样做有什么意义？我直接打开空口日志分析不就得了？

实际上，在空口日志比较小的时候，这样做是很简单的。

但是假如空口日志达到了几个G、甚至十几个G的时候，你就会发现Wireshark的UI界面成了你分析问题的最大阻力，每做一个小动作，都可能等待十几、几十秒才会有响应。

这种情况下做分析十分痛苦的。

因此我们通过一系列的预处理动作，来对空口进行初步的分析，这样可以有效减少时间成本。

同时，还为以后的日志自动化分析系统补全了重要的一步。



我们主要依靠命令行来对空口日志文件进行预处理。在没有了Wireshark的UI界面限制的情况下，处理起来十分方便。比如：

(1) capinfos.exe可以直接查看抓包文件的信息
当我们手里有一个大文件，想在不打开它的前提下知道它包含了802.11帧的起止时间点，可以用capinfos.exe命令。

capinfos.exe -ae air.pcap

File name: air_cut.pcap
First packet time: 2023-04-19 17:26:34.617311
Last packet time: 2023-04-19 17:27:43.748532

(2) mergecap.exe可以合并n个抓包文件到一个大文件
当我们手里有许多的小抓包文件，想要拼接起来的一起查看的时候，不用打开Wireshark再把这些文件往里面拖了，而是直接用mergecap.exe命令。

mergecap.exe air1.pcap air2.pcap air3.pcap -w air.pcap

(3) tshark.exe可以直接过滤出想要的数据包
tshark.exe实际上就是命令行版本的wireshark，因为没有UI界面，执行起来非常迅速。

tshark.exe -r air.pcap -w air_cut.pcapng -Y <filter>

这个处理动作是我最经常用的，它可以在不打开抓包文件的情况下按照特定filter来对原始air.pcap进行处理，过滤出想要的数据包集合。

有的同学问了，这和打开Wireshark再应用该过滤条件有何区别？简单说，小型抓包文件没什么区别，10G以上的抓包文件就有很大区别了。



(4) 其他会用到的命令
还有一些其他可以用到的命令行，都在C:\Program Files\Wireshark\下面，帮助文件都是一些HTML，同学们可以自行查看。





2. 使用Wireshark对空口包文件进行分析
这节内容是本文的重点，主要应用于分析空口日志到底出了什么问题的场景。



在掌握分析空口日志的方法论之前，我们首先需要了解一些Wireshark这个软件的基础和高级使用方式，见：Wireshark使用方法和技巧。

(1) 数据包纯净化和统计信息
我们对数据包进行一些初步的纯净化，了解一些统计信息。

I. 确定你要分析问题的两端设备的MAC地址，以及时间点
这些信息需要去从设备的AP日志中获得，具体过程不赘述。

II. 在抓包文件的显示过滤器对话框中输入指定的过滤条件
对于两个设备，一般使用它们的MAC地址的并集，这样可以把所有相关的帧都包含进来，例如：





对于76:3f:f1:c5:fd:53和3a:68:93:67:4e:cc这两个设备，我们使用并集来过滤出所有跟这两个地址交互的数据帧。



III. 查看关键帧是否有缺失
比如上面的贴图里，Auth、Association Req、Association Resp、Deauth这些关键帧都在。



IV. 查看统计信息
这一步其实也可以作为第0步进行。









因为我这里已经是针对76:3f:f1:c5:fd:53和3a:68:93:67:4e:cc这两个地址过滤过了的空口包，所以统计信息看起来很干净。

我们可以看到SSID、按组百分比(其实就是我们想看的这个SSID的帧占这个抓包文件的帧总数量的百分比)，重试(重传)，重试百分比和其他的一些信息。



注意！如果是在开放环境下抓包或没有经过特定的过滤条件，那么按组百分比这里可能就会小一些，例如80%，这说明有其他的SSID在同时进行数据帧传输。

干扰越多，纯净程度越低，按组百分比就越小。



(2) 常用过滤条件
在Wireshark的显示过滤器输入框中输入一些特定的过滤条件，就可以对数据帧进行过滤。

下面是一些常用的过滤条件及其含义。



I. 设备地址的并集
上面已经演示过两个设备地址的并集。设备地址使用关键字wlan.addr，注意这是802.11的MAC地址；操作符一般使用" == "，来表示相等的意思；条件使用"or"，表示"或"的意思，实际上就是并集。如果是and，就是交集。



II. 特定帧类型
帧类型使用关键字wlan.fc.type_subtype。一般的帧不需要牢记，而关键帧的数值，比如Auth(11)，Assoc Req(0)，Assoc Resp(1)，Deauth(12)等等需要记清楚。

还有一类关键帧：EAPOL，不使用wlan.fc.type_subtype，而是直接使用eapol.version == 1这个条件。



所以对于关键帧来说，过滤条件是：wlan.fc.type_subtype in { 0 1 11 12} or eapol.version == 1



III. 发包/收包
收发包可以使用wlan.sa(源地址)和wlan.da(目的地址)，不过由于802.11的特殊性，我们更常使用wlan.ta(发送地址)和wlan.ra(接收地址)。

比如，76:3f:f1:c5:fd:53发包而3a:68:93:67:4e:cc收包，我们可以把过滤条件写成：wlan.ta == 76:3f:f1:c5:fd:53 and wlan.ra == 3a:68:93:67:4e:cc，注意这里要用and。



IV. 特定字段过滤
比如，我们想过滤所有QoS Data的数据包，它的Bandwidth是20MHz，只需要在Bandwidth: 20MHz这一行点击右键，Prepare as Filter，然后点击"选中"，这样就会自动把wlan_radio.11ac.bandwidth == 0这个条件写入到输入框，我们直接按回车就可以了，非常方便。





(3) 经常用到的列
有的时候，我们希望直接能看到某些属性值，而不是去点到某个数据包去查看，那样太麻烦。

我们可以把这些属性值应用为列，这样就可以像excel列名一样查看其属性值了。



我常用到的列有以下这些，同学们可以根据上面的方法自行定制。




(4) 常见的帧组合场景
本节内容列举了一些常见的帧组合场景，这些场景里往往每一类常见帧都会出现的。

正常来说，如果每一个帧都被捕获到了，那就应该都出现在空口数据包了。

不过也有一些例外的情况，需要根据上下文来判断。

I. AP/GO广播
不论是AP还是GO，在启动后都应该进行Beacon广播，以便向周围的STA表明自己的能力。



在上面的截图中，我们可以看到SSID是超级终端默认的DIRECT-xx-honor的形式(x为大小写字母和数字)。



如果没有看到Beacon，很可能是AP/GO没有启动起来。



II. STA/GC主动扫描
STA/GC会主动发送Probe Req(广播)，AP/GO会回复Probe Resp(单播)，STA/GC再发送一个ACK，一般情况下这3个帧是一组。



III. STA/GC发起认证
STA/GC发送auth帧，AP/GO回复auth帧。当然每个auth帧收到后都会回复一个ACK。





IV. STA/GC发起关联
STA/GC发送Assoc Req，AP/GO回复Assoc Resp。同样每个关联帧收到后都会回复一个ACK。





V. EAPoL帧
密钥交换过程，一共4个EAPoL帧，同样每个EAPoL帧收到后都会回复一个ACK。





VI. Action帧 - AMPDU协商
在密钥协商完成后，一定会有一对Action帧，表明两端协商AMPDU完成，以便为了后续的高吞吐量帧的交互进行准备工作。



没有这一对的话，表明没有协商AMPDU，吞吐量会保持在低速。



VII. RTS/CTS
RTS和CTS往往成对出现，表明一端要准备发送数据帧了。



VIII. AMPDU传输
在RTS/CTS后，一端发送大量的数据帧，往往几十个，最多63或255个。在这种情况下，接收端不会一个一个回复ACK，而是回复一个BA，表明收到了多少数据包。全f表明所有的数据包都收到了。





IX. Deauth断开
当一端想要断开时，往往会主动发送Deauth帧，对端收到后会回复一个ACK(有时也不回复ACK)。



在上面的截图中，AP/GO的Beacon在收到deauth后很快就停止了，说明它关闭了。



上面这些常见的802.11帧场景全部都是正常情况下的。当出现异常时，或多或少都能与这9个场景之一产生关联，且缺少一些东西(或多一些东西)，总之看起来不正常。

当然，到底哪里不正常，还是需要依靠经验的积累和大量空口日志的查阅才能下判断。

在后面的章节里，我们将会挑选一些典型的错误场景来进行举例。



3. 使用Omnipeek对空口包进行分析
使用Omnipeek这个工具，同样按照上面Wireshark的思路进802.11帧进行分析。

Omnipeek的特点是，它本身自带大量的分析诊断内容，可以帮助用户直接看到一些统计信息。

从这个角度来看，其实Omnipeek更类似于一个诊断分析工具。





上面是Omnipeek自带的sample里面的一个抓包。我们可以看做在最左边有非常多的自菜单可以点击。



我们主要关心Statistics中的Summary这一块内容。



我们可以看到Omnipeek已经把许多内容整理好了，我们可以直接看到这些项的细节信息。

篇幅所限就不多介绍了。

四、典型空口日志举例
在本章内容中，我们将列举一些发生异常的空口日志，并指出问题的所在。

需要强调的是，尽量把确认到底发生了什么问题的空口文件保存好，可以对以后快速定位类似的问题起到相当大的参考作用。



1. GO不发送Beacon
在某个超级终端的场景下，GC连接不上GO。经过查看空口，发现本应开启的GO并没有发送Beacon。

在这种情况下，由于GC扫描不到GO，最终导致P2P连接建立失败了。



可以看到中间足足有20秒的时间没有发送Beacon，由此导致P2P建立失败。



此问题整体分析在：http://ota-wiki.rnd.hihonor.com/x/-T6u

2.GC连接时间过长
在某个超级终端的场景下，大屏连接PC的时间过长，P2P建立连接耗时大于2500ms，最终导致不达标。

查看空口，我们发现GO并没有第一时间响应GC的auth，导致GC多次重传：





可以看到SN从0开始一直重传到了6，才被GO正确响应，发送了auth作为回复。

那么这次P2P连接尝试，从17:36:51开始到17:37:00才成功，足足耗时9秒。



此问题整体分析在：http://ota-wiki.rnd.hihonor.com/x/BINUAQ



3.四路握手/密钥协商超时
某个双PC的超级终端场景下，P2P连接建立失败了。在对应的空口中，我们发现之前的管理帧都是正常的。

但是到了四路握手的时候，两端并没有完成4个EAPoL帧的协商，而是在中途中止了，GC发送了deauth帧断开了尝试。





此问题整体分析在：http://ota-wiki.rnd.hihonor.com/x/zy2u

4. 2.4GHz路由器组网，PC发送文件给手机/平板失败
在超级终端的某个PC传输文件到手机/平板的过程中，意外断连。

断连的原因是，PC没有收到手机/平板发送的UDP ACK，最后导致认为传输已经断开了。

那么为什么PC没有收到每秒钟会有几个的UDP ACK呢？



我们从上图中可以看到，148011行是出问题前的最后一个UDP ACK，然后就再也没有了。

这是因为9f:be一直在请求192.168.31.222的mac地址，而路由器03:f6在广播这个请求。

a2:f4在收到这个请求后，马上就把自己的ARP响应发送给路由器了。

那么下一步就应该是路由器把这个响应转发给9f:be，9f:be收到之后就能发送UDP ACK了。

但是，我们看到始终没有TA == 03:f6，RA == 9f:be的帧，也就是路由器始终没有转发ARP响应给9f:be。

这就导致9f:be始终不知道192.168.31.222的mac地址是a2:f4。

直到13秒之后，在209613行，路由器03:f6才成功转发了该ARP响应给9f:be。

马上，在209629行，9f:be(192.168.31.235)就可以发送UDP ACK包给192.168.31.222了(但接收地址仍然是路由器03:c6，这个UDP ACK会由路由器转发给a2:f4)。



此问题整体分析在：http://ota-wiki.rnd.hihonor.com/x/3jKu

5. P2P吞吐量低
某个超级终端场景，P2P吞吐量低。我们发现，在PC发送了一大堆数据包后，平板并没有如同正常一样回复BA，这就迫使PC又把数据包重复发送了一遍，最后导致吞吐量低。





6. Rx收包异常
这种情况和上面的场景类似，不过更加极端。

截图只显示了一小部分。在PC(f3:ae)发包时，接收端没有发送任何帧，包括ACK/BA，时间长达几十秒。

这说明，接收端没有认为自己收到了任何数据帧，所以是Rx收包异常问题。





7. 两端不发数据包
在某个超级终端场景下，两端都没有做任何业务。这就导致双方都没有发送任何有意义的数据帧，时间长达几十秒。



我们可以看到在20600行，平板给PC发送了最后一个数据帧，表明自己进入了休眠，之后GO一直在发送Beacon。



一直到21321行，此时GO已经停止Beacon并关闭了，而平板再次给GO发送数据帧，当然就得不到任何回应了。



从空口包中可以看出，两者有长达21秒的时间并没有交互任何数据帧。



此问题整体分析在：http://ota-wiki.rnd.hihonor.com/x/4D6u

8.GO发包，GC唤不醒
在某个超级终端场景下，GC处于休眠状态，此时GO意图发数据帧给GC。

在这种情况下，GO首先在发出的Beacon中携带GC的Aid，指示GC有缓存的数据需要它接收。

GC此时应该醒来，并告诉GO我已经醒来了，GO才会把缓存的数据包发送给GC。

此时异常情况出现了，GO无论怎么发送待Aid的Beacon，GC就是醒不来。





我们来看正常情况下，GO发送的Beacon不带aid，那么GC进入了休眠时后，两端不再交互数据包，GO按部就班的发送Beacon。

直到142975行时，GO发送了aid == 0x02的Beacon，说明有缓存的数据包要发送给GC。

此时GC醒来，发送了一个"stay up"的数据帧给GO告诉它我已经醒来了。

然后GO发送了7个QoS Data，GC成功接下了之后发送了BA。



但是在出现问题时，我们发现GC在进入休眠后，GO又发送了带aid == 0x02的Beacon。但这次，GC无论如何醒不来了。





此问题整体分析在：http://ota-wiki.rnd.hihonor.com/x/y4dUAQ

9. GC频繁休眠
在某个荣耀分享的场景下，P2P的吞吐量较低。






在上图中，正常情况下，帧类型按照RTS => CTS=> Qos Data=> BA的顺序传输。







在上图中，出现问题的情况下，我们看到在上一轮的BA结束后，GC很快的发送了一个休眠帧，然后又醒过来了，才继续进行传输。

但这一睡一醒之间，已经浪费了9毫秒左右。





经统计后，发现在17:13:08这一秒内，GC就休眠了几十次。



此问题整体分析在：http://ota-wiki.rnd.hihonor.com/x/LZZUAQ

10. 能力位变来变去
在某个漫游场景中，AP和STA都宣称自己支持BSS Transition：






但是在STA连接到路由器时，有两个probe req和一个Reassoc Req中的该能力位突然宣称不支持了



然后在连接成功后的probe req中又宣称支持了。



此问题整体分析在：http://ota-wiki.rnd.hihonor.com/x/JJZUAQ



顺便，这张图里面缺失了Assoc Req和Assoc Resp，以及四路握手的前三个EAPoL帧，但是最后还是连接成功了，这充分体现了抓包时的不完整性。

五、FAQ
本章主要记录一些在抓包过程中的经常遇到的问题。

1. 空口包太大怎么办？
熟练使用tcpdump的-s和-C参数，-s用来截取每个802.11帧的字节数，一般500就够用了；-C用来指定每个保存文件的大小，对于空口数据包文件来说，100MB到500MB都可以，我个人喜欢使用100MB。

这样打开抓包文件的时候不会导致Wireshark卡顿。当然，100MB对于空口可能只包含几秒左右的数据，这样定位的时候可能要多看看问题时间点附近几个抓包文件才能定位具体问题。

对于全部数据不敏感的场景，比如iPerf长时间打流，可以合并使用-s和-C参数，这样可以有效缩短抓包文件最终的大小。

当然，这样做也有很小的几率没有抓到想要的数据，需要重新抓。



2. 使用了-C参数，最后形成的抓包文件数量过多，怎么办？
抓包文件会以air.pcap、air.pcap1、air.pcap2....这样的形式存在，文件后缀名的数字会逐步递增。

那么pull的时候呢，只pull自己想要的文件就可以了，比如问题时间点前后的几个文件。

如果真的想要pull所有的文件，建议直接pull在脚本中建好的/data/tmp文件夹。



3. 抓包时没有看到想要的包怎么办？
抓包时一定会有遗漏，抓不全的。不过一般情况下不会这么凑巧没抓到想要的包的。

如果确实想避免这种情况发生，可以多准备几台抓包机一起抓。



4. 一定要在屏蔽室吗？工位环境行不行？
最好在屏蔽室里，能最大程度排除外界的干扰。

次之就是在楼梯间环境。

如果实在不行也就只能在工位环境了，但要有重新抓的思想准备。



5. 信道和频宽到底怎么确定？
频宽好说，一般2.4GHz就使用20MHz，5GHz的就使用80MHz。



信道的确定则麻烦的多。策略是这样的：

如果是长期开启的AP/路由器，只需要找一台观察手机，打开"开发者选项"中的"WLAN详细日志"功能，然后去Wi-Fi菜单下面去扫想要抓包的SSID，就会显示出来它的工作信道。
如果是临时开启的SAP，比如手机热点，条件允许的情况下可以输入特定命令行来预先设置热点的工作信道(注意，必须先执行命令再打开热点)：
adb shell cmd wifi force-softap-channel enabled <频率>  

比如频率值5180，就是把热点信道设为36。

如果没有输入命令行的条件，可以尝试把热点手机的Wi-Fi连接到某一个信道上，这样热点开启后的工作信道也是这个Wi-Fi的信道，即手机热点的信道和手机Wi-Fi的信道是一致的(相同频段时)。
P2P的信道由于是随机建立的，整体上要麻烦得多，可以参考我的这篇文章：抓空口包时候的信道选择策略


6. 高难度抓包场景？
举个例子，有一个涉及到漫游的场景： 两台路由器信道不一致，一台手机需要从其中一台漫游到另外一台。

这个时候，由于信道不一致，你没有办法抓全它的整个漫游场景中交互的帧。

所以简单但是有用的方案就是：准备两台抓包机，分别工作在两台路由器的信道上，这样一定可以把整个漫游过程抓完整。



有的同学可能想到了，对于信道不能确定这种场景，比如P2P的建立，我们在每一个可能的信道上都布设上抓包机不就得了？

没错，如果P2P建立在5GHz上，只要最多8台抓包机就可以占满36~48、149~161信道了。



7. 哪个抓包工具好用？
目前来看，基本上我们只有选择tcpdump + 高通手机这对组合，其他方案不是需要特定网卡和驱动，就是有各种缺陷，要不就是成本高。



8. P2P的密钥如何获取？
比较简单的方式是在Android设备上命令行：

adb shell 'cmd wifienhance "WifiP2pExt GetP2pInfo"'

记得要把P2P关联过程也抓上，也就是先开始抓包，再建立P2P连接。

9. 为什么有时tcpdump抓出来的内容是空的？
通常来说，只要在执行抓包命令/脚本时确保每一条都执行成功，没有报错，那就不会发生这种现象。

请从脚本执行开始确认每一条命令都没有发生错误，或者手动方式挨个输入每一条命令

实在不行的话，只能重启抓包手机再试了。



10. 为啥5GHz频段上的165信道抓不到或者抓不全？
因为5825MHz上允许使用的频宽只有20MHz，所以抓包参数中，setMonChan的第二个参数的值是0，而不是2！切记切记。





六、杂项
本章内容不固定，用于放置一些相关的概念和事项。

概念澄清
抓包/空口包/空口日志/air log/sniffer log：这些说法其实指的都是一个东西，那就是本文讨论的空口日志，或者说802.11帧(注意这是MAC层的东西)。

IP数据包/网络数据包/网络日志/net log：这些说法指的其实也是一个东西，那就是IPv4数据包(其实也包含一些MAC层的东西，但是占比很小，主要还是IP层次的东西)。



注意！不建议使用tcpdump log/tcpdump日志这种含义不清的名称，容易产生歧义。



注意事项
抓包机尽量不要运行其他程序，专机专用
一定要把建立Wi-Fi连接、P2P连接的全过程抓进去，主要是为了抓取关联帧，为以后的解密空口包做准备
打开Android设备开发者选项中的"WLAN详细日志功能"就可以扫描周边Wi-Fi所在的信道了，很方便
Wi-Fi的SSID中尽量不要包含空格、特殊字符和汉字，尤其是汉字，会导致解密失败的(部分特殊字符也会)！
Wi-Fi不要使用165信道！它虽然是5GHz，但是是20MHz频宽的。
 <待补充>


非法帧


一个广播的deauth帧







七、引用文献
1. Wi-Fi空口日志抓取时的细节和注意事项

2. 抓空口包时候的信道选择策略

3. Wireshark解密空口包

4. 时间同步的必要性

5. Intel PC抓取log注意事项
